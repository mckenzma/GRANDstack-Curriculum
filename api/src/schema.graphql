type Rank {
  # id: ID!
  nameShort: String
  nameLong: String
  strike: [Strike] @relation(name: "REQUIRED_FOR", direction: "IN")
  block: [Block] @relation(name: "REQUIRED_FOR", direction: "IN")
  kick: [Kick] @relation(name: "REQUIRED_FOR", direction: "IN")
}

type Strike {
  # name: ID!
  name: String!
  steps: [StepDescription] @relation(name: "STEP_FOR", direction: "IN")
  rank: [Rank] @relation(name: "REQUIRED_FOR", direction: "OUT")
} 

type StepDescription {
  _id: ID!
  text: String
  number: String
  strike: [Strike] @relation(name: "STEP_FOR", direction: "OUT")
  block: [Block] @relation(name: "STEP_FOR", direction: "OUT")
  kick: [Kick] @relation(name: "STEP_FOR", direction: "OUT")
  stance: [Stance] @relation(name: "STEP_FOR", direction: "OUT")
  movement: [Movement] @relation(name: "STEP_FOR", direction: "OUT")
  turn: [Turn] @relation(name: "STEP_FOR", direction: "OUT")
}

type Block {
  name: ID!
  steps: [StepDescription] @relation(name: "STEP_FOR", direction: "IN")
  rank: [Rank] @relation(name: "REQUIRED_FOR", direction: "OUT")
}

type Kick {
  name: ID!
  steps: [StepDescription] @relation(name: "STEP_FOR", direction: "IN")
  rank: [Rank] @relation(name: "REQUIRED_FOR", direction: "OUT")
}

type Stance {
  name: ID!
  steps: [StepDescription] @relation(name: "STEP_FOR", direction: "IN")
  rank: [Rank] @relation(name: "REQUIRED_FOR", direction: "OUT")
}

type Movement {
  name: ID!
  steps: [StepDescription] @relation(name: "STEP_FOR", direction: "IN")
  rank: [Rank] @relation(name: "REQUIRED_FOR", direction: "OUT")
}

type Turn {
  name: ID!
  steps: [StepDescription] @relation(name: "STEP_FOR", direction: "IN")
  rank: [Rank] @relation(name: "REQUIRED_FOR", direction: "OUT")
}

# type Query {
#     # usersBySubstring(substring: String, first: Int = 10, offset: Int = 0): [User] @cypher(statement: "MATCH (u:User) WHERE u.name CONTAINS $substring RETURN u")
# }