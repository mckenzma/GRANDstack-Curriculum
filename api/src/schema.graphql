type Rank {
  # id: ID!
  name: String!
  rankOrder: Int!
  strike: [Strike] @relation(name: "REQUIRED_FOR", direction: "IN")
  block: [Block] @relation(name: "REQUIRED_FOR", direction: "IN")
  kick: [Kick] @relation(name: "REQUIRED_FOR", direction: "IN")
}

type Strike {
  # name: ID!
  name: String!
  steps: [StepDescription] @relation(name: "STEP_FOR", direction: "IN")
  rank: [Rank] @relation(name: "REQUIRED_FOR", direction: "OUT")
} 

type StepDescription {
  _id: ID!
  text: String
  number: String
  strike: [Strike] @relation(name: "STEP_FOR", direction: "OUT")
  block: [Block] @relation(name: "STEP_FOR", direction: "OUT")
  kick: [Kick] @relation(name: "STEP_FOR", direction: "OUT")
  stance: [Stance] @relation(name: "STEP_FOR", direction: "OUT")
  movement: [Movement] @relation(name: "STEP_FOR", direction: "OUT")
  turn: [Turn] @relation(name: "STEP_FOR", direction: "OUT")
}

type Block {
  # name: ID!
  name: String!
  steps: [StepDescription] @relation(name: "STEP_FOR", direction: "IN")
  rank: [Rank] @relation(name: "REQUIRED_FOR", direction: "OUT")
}

type Kick {
  # name: ID!
  name: String!
  steps: [StepDescription] @relation(name: "STEP_FOR", direction: "IN")
  rank: [Rank] @relation(name: "REQUIRED_FOR", direction: "OUT")
}

type Stance {
  # name: ID!
  name: String!
  steps: [StepDescription] @relation(name: "STEP_FOR", direction: "IN")
  rank: [Rank] @relation(name: "REQUIRED_FOR", direction: "OUT")
}

type Movement {
  # name: ID!
  name: String!
  steps: [StepDescription] @relation(name: "STEP_FOR", direction: "IN")
  rank: [Rank] @relation(name: "REQUIRED_FOR", direction: "OUT")
}

type Turn {
  # name: ID!
  name: String!
  steps: [StepDescription] @relation(name: "STEP_FOR", direction: "IN")
  rank: [Rank] @relation(name: "REQUIRED_FOR", direction: "OUT")
}

# type Query {
  
#   connectStrikeToRank(ranks: [String]): @cypher(statement: """
#     MERGE (this)
#     UNWIND $ranks AS rank
#     MERGE (this)-[:REQUIRED_FOR]->(rank)
#     """
#   )

# }