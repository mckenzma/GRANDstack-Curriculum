type Rank {
  id: ID!
  rankOrder: Int!
  name: String!
  abbreviation: String!
  
  strikes: [Strike] @relation(name: "REQUIRED_FOR", direction: "IN")
  blocks: [Block] @relation(name: "REQUIRED_FOR", direction: "IN")
  kicks: [Kick] @relation(name: "REQUIRED_FOR", direction: "IN")
  stances: [Stance] @relation(name: "REQUIRED_FOR", direction: "IN")
  movements: [Movement] @relation(name: "REQUIRED_FOR", direction: "IN")
  turns: [Turn] @relation(name: "REQUIRED_FOR", direction: "IN")
  katas: [Kata] @relation(name: "REQUIRED_FOR", direction: "IN")
}

# TODO - Figure out how to use a shared Technique label
interface Technique {
  id: ID!
  name: String!
  description: String

  # steps: [Step] @relation(name: "USES", direction: "IN")
}

# type Strike {
type Strike implements Technique {
  id: ID!
  name: String!
  description: String

  firstRank: String @cypher(
    statement:
    """
    OPTIONAL MATCH (this)-[:REQUIRED_FOR]->(rank)
    WITH rank
    ORDER BY rank.rankOrder ASC
    WITH rank LIMIT 1
    WITH CASE rank
          WHEN null THEN ''
          ELSE rank.id
         END AS firstRank
    RETURN firstRank
    """
  )

  # steps: [StepDescription] @relation(name: "STEP_FOR", direction: "IN")
  ranks: [Rank] @relation(name: "REQUIRED_FOR", direction: "OUT")
  steps: [Step] @relation(name: "USES", direction: "IN")
} 

# type StepDescription {
#   id: ID!
#   text: String
#   number: String
#   strike: [Strike] @relation(name: "STEP_FOR", direction: "OUT")
#   block: [Block] @relation(name: "STEP_FOR", direction: "OUT")
#   kick: [Kick] @relation(name: "STEP_FOR", direction: "OUT")
#   stance: [Stance] @relation(name: "STEP_FOR", direction: "OUT")
#   movement: [Movement] @relation(name: "STEP_FOR", direction: "OUT")
#   turn: [Turn] @relation(name: "STEP_FOR", direction: "OUT")
# }

# type Block {
type Block implements Technique {
  id: ID!
  name: String!
  description: String

  firstRank: String @cypher(
    statement:
    """
    OPTIONAL MATCH (this)-[:REQUIRED_FOR]->(rank)
    WITH rank
    ORDER BY rank.rankOrder ASC
    WITH rank LIMIT 1
    WITH CASE rank
          WHEN null THEN ''
          ELSE rank.id
         END AS firstRank
    RETURN firstRank
    """
  )

  # steps: [StepDescription] @relation(name: "STEP_FOR", direction: "IN")
  ranks: [Rank] @relation(name: "REQUIRED_FOR", direction: "OUT")
  steps: [Step] @relation(name: "USES", direction: "IN")
}

# type Kick {
type Kick implements Technique {
  id: ID!
  name: String!
  description: String

  firstRank: String @cypher(
    statement:
    """
    OPTIONAL MATCH (this)-[:REQUIRED_FOR]->(rank)
    WITH rank
    ORDER BY rank.rankOrder ASC
    WITH rank LIMIT 1
    WITH CASE rank
          WHEN null THEN ''
          ELSE rank.id
         END AS firstRank
    RETURN firstRank
    """
  )

  # steps: [StepDescription] @relation(name: "STEP_FOR", direction: "IN")
  ranks: [Rank] @relation(name: "REQUIRED_FOR", direction: "OUT")
  steps: [Step] @relation(name: "USES", direction: "IN")
}

# type Stance {
type Stance implements Technique {
  id: ID!
  name: String!
  description: String

  firstRank: String @cypher(
    statement:
    """
    OPTIONAL MATCH (this)-[:REQUIRED_FOR]->(rank)
    WITH rank
    ORDER BY rank.rankOrder ASC
    WITH rank LIMIT 1
    WITH CASE rank
          WHEN null THEN ''
          ELSE rank.id
         END AS firstRank
    RETURN firstRank
    """
  )

  # steps: [StepDescription] @relation(name: "STEP_FOR", direction: "IN")
  ranks: [Rank] @relation(name: "REQUIRED_FOR", direction: "OUT")
  steps: [Step] @relation(name: "USES", direction: "IN")
}

# type Movement {
type Movement implements Technique {
  id: ID!
  name: String!
  description: String

  firstRank: String @cypher(
    statement:
    """
    OPTIONAL MATCH (this)-[:REQUIRED_FOR]->(rank)
    WITH rank
    ORDER BY rank.rankOrder ASC
    WITH rank LIMIT 1
    WITH CASE rank
          WHEN null THEN ''
          ELSE rank.id
         END AS firstRank
    RETURN firstRank
    """
  )

  # steps: [StepDescription] @relation(name: "STEP_FOR", direction: "IN")
  ranks: [Rank] @relation(name: "REQUIRED_FOR", direction: "OUT")
  steps: [Step] @relation(name: "USES", direction: "IN")
}

# type Turn {
type Turn implements Technique {
  id: ID!
  name: String!
  description: String

  firstRank: String @cypher(
    statement:
    """
    OPTIONAL MATCH (this)-[:REQUIRED_FOR]->(rank)
    WITH rank
    ORDER BY rank.rankOrder ASC
    WITH rank LIMIT 1
    WITH CASE rank
          WHEN null THEN ''
          ELSE rank.id
         END AS firstRank
    RETURN firstRank
    """
  )

  # steps: [StepDescription] @relation(name: "STEP_FOR", direction: "IN")
  ranks: [Rank] @relation(name: "REQUIRED_FOR", direction: "OUT")
  steps: [Step] @relation(name: "USES", direction: "IN")
}

type Kata {
  id: ID!
  name: String!
  # description: String

  firstRank: String @cypher(
    statement:
    """
    OPTIONAL MATCH (this)-[:REQUIRED_FOR]->(rank)
    WITH rank
    ORDER BY rank.rankOrder ASC
    WITH rank LIMIT 1
    WITH CASE rank
          WHEN null THEN ''
          ELSE rank.id
         END AS firstRank
    RETURN firstRank
    """
  )

  # steps: [StepDescription] @relation(name: "STEP_FOR", direction: "IN")
  ranks: [Rank] @relation(name: "REQUIRED_FOR", direction: "OUT")
  moves: [Move] @relation(name: "HAS_MOVE", direction: "OUT")
  orderedMoves: [Move] @cypher(
    statement: 
    """
    MATCH (this)-[:HAS_MOVE]->(start)
    WHERE NOT ()-[:NEXT_MOVE]->(start)
    WITH [(start)-[:NEXT_MOVE*0..]->(move) | move] AS moves
    UNWIND moves AS move
    RETURN move
    """
  )
}

type Move {
  id: ID!
  name: String!

  kata: Kata @relation(name: "HAS_MOVE", direction: "IN")
  nextMove: Move @relation(name: "NEXT_MOVE", direction: "OUT")
  prevMove: Move @relation(name: "NEXT_MOVE", direction: "IN")
  steps: [Step] @relation(name: "HAS_STEP", direction: "OUT")
  orderedSteps: [Step] @cypher(
    statement: 
    """
    MATCH (this)-[:HAS_STEP]->(start)
    WHERE NOT ()-[:NEXT_STEP]->(start)
    WITH [(start)-[:NEXT_STEP*0..]->(step) | step] AS steps
    UNWIND steps AS step
    RETURN step
    """
  )
}

type Step {
  id: ID!
  name: String!

  move: Move @relation(name: "HAS_STEP", direction: "IN")
  nextStep: Step @relation(name: "NEXT_STEP", direction: "OUT")
  prevStep: Step @relation(name: "NEXT_STEP", direction: "IN")

  technique: Technique @relation(name: "USES", direction: "OUT")
  block: Block @relation(name: "USES", direction: "OUT")
  strike: Strike @relation(name: "USES", direction: "OUT")
  kick: Kick @relation(name: "USES", direction: "OUT")
  stance: Stance @relation(name: "USES", direction: "OUT")
  turn: Turn @relation(name: "USES", direction: "OUT")
  movement: Movement @relation(name: "USES", direction: "OUT")
}

type Mutation {
  MergeStrikeRanks(fromStrikeID: ID!, toRankIDs: [ID!]): [Rank] @cypher(
    statement:
    """
    MATCH (strike:Strike {id: $fromStrikeID})
    UNWIND $toRankIDs AS toRankID
    MATCH (rank:Rank {id: toRankID})
    MERGE (strike)-[:REQUIRED_FOR]->(rank)
    RETURN rank
    """
  )

  DeleteStrikeRanks(fromStrikeID: ID!, toRankIDs: [ID!]): [Rank] @cypher(
    statement:
    """
    MATCH (strike:Strike {id: $fromStrikeID})-[r:REQUIRED_FOR]->(rank:Rank)
    WHERE rank.id IN $toRankIDs
    DELETE r
    RETURN rank
    """
  )

  MergeBlockRanks(fromBlockID: ID!, toRankIDs: [ID!]): [Rank] @cypher(
    statement:
    """
    MATCH (block:Block {id: $fromBlockID})
    UNWIND $toRankIDs AS toRankID
    MATCH (rank:Rank {id: toRankID})
    MERGE (block)-[:REQUIRED_FOR]->(rank)
    RETURN rank
    """
  )

  DeleteBlockRanks(fromBlockID: ID!, toRankIDs: [ID!]): [Rank] @cypher(
    statement:
    """
    MATCH (block:Block {id: $fromBlockID})-[r:REQUIRED_FOR]->(rank:Rank)
    WHERE rank.id IN $toRankIDs
    DELETE r
    RETURN rank
    """
  )

  MergeKickRanks(fromKickID: ID!, toRankIDs: [ID!]): [Rank] @cypher(
    statement:
    """
    MATCH (kick:Kick {id: $fromKickID})
    UNWIND $toRankIDs AS toRankID
    MATCH (rank:Rank {id: toRankID})
    MERGE (kick)-[:REQUIRED_FOR]->(rank)
    RETURN rank
    """
  )

  DeleteKickRanks(fromKickID: ID!, toRankIDs: [ID!]): [Rank] @cypher(
    statement:
    """
    MATCH (kick:Kick {id: $fromKickID})-[r:REQUIRED_FOR]->(rank:Rank)
    WHERE rank.id IN $toRankIDs
    DELETE r
    RETURN rank
    """
  )

  MergeStanceRanks(fromStanceID: ID!, toRankIDs: [ID!]): [Rank] @cypher(
    statement:
    """
    MATCH (stance:Stance {id: $fromStanceID})
    UNWIND $toRankIDs AS toRankID
    MATCH (rank:Rank {id: toRankID})
    MERGE (stance)-[:REQUIRED_FOR]->(rank)
    RETURN rank
    """
  )

  DeleteStanceRanks(fromStanceID: ID!, toRankIDs: [ID!]): [Rank] @cypher(
    statement:
    """
    MATCH (stance:Stance {id: $fromStanceID})-[r:REQUIRED_FOR]->(rank:Rank)
    WHERE rank.id IN $toRankIDs
    DELETE r
    RETURN rank
    """
  )

  MergeMovementRanks(fromMovementID: ID!, toRankIDs: [ID!]): [Rank] @cypher(
    statement:
    """
    MATCH (movement:Movement {id: $fromMovementID})
    UNWIND $toRankIDs AS toRankID
    MATCH (rank:Rank {id: toRankID})
    MERGE (movement)-[:REQUIRED_FOR]->(rank)
    RETURN rank
    """
  )

  DeleteMovementRanks(fromMovementID: ID!, toRankIDs: [ID!]): [Rank] @cypher(
    statement:
    """
    MATCH (movement:Movement {id: $fromMovementID})-[r:REQUIRED_FOR]->(rank:Rank)
    WHERE rank.id IN $toRankIDs
    DELETE r
    RETURN rank
    """
  )

  MergeTurnRanks(fromTurnID: ID!, toRankIDs: [ID!]): [Rank] @cypher(
    statement:
    """
    MATCH (turn:Turn {id: $fromTurnID})
    UNWIND $toRankIDs AS toRankID
    MATCH (rank:Rank {id: toRankID})
    MERGE (turn)-[:REQUIRED_FOR]->(rank)
    RETURN rank
    """
  )

  DeleteTurnRanks(fromTurnID: ID!, toRankIDs: [ID!]): [Rank] @cypher(
    statement:
    """
    MATCH (turn:Turn {id: $fromTurnID})-[r:REQUIRED_FOR]->(rank:Rank)
    WHERE rank.id IN $toRankIDs
    DELETE r
    RETURN rank
    """
  )

  MergeKataRanks(fromKataID: ID!, toRankIDs: [ID!]): [Rank] @cypher(
    statement:
    """
    MATCH (kata:Kata {id: $fromKataID})
    UNWIND $toRankIDs AS toRankID
    MATCH (rank:Rank {id: toRankID})
    MERGE (kata)-[:REQUIRED_FOR]->(rank)
    RETURN rank
    """
  )

  DeleteKataRanks(fromKataID: ID!, toRankIDs: [ID!]): [Rank] @cypher(
    statement:
    """
    MATCH (kata:Kata {id: $fromKataID})-[r:REQUIRED_FOR]->(rank:Rank)
    WHERE rank.id IN $toRankIDs
    DELETE r
    RETURN rank
    """
  )

  # CreateStepConnectToMove(fromMoveID: ID!): Step @cypher(
  #   statement:
  #   """
  #   CREATE (newStep:Step)
  #   SET newStep.name = ''
  #       newStep.id = apoc.create.uuid()
  #   WITH newStep
  #   MATCH (move:Move {id: $fromMoveID})
  #   MERGE (move)-[:HAS_STEP]->(newStep)
  #   RETURN newStep
  #   """
  # )

  ConnectMoveToStep(fromMoveID: ID!, toStepID: ID!): Step @cypher(
    statement:
    """
    MATCH (move:Move {id: $fromMoveID})
    MATCH (step:Step {id: $toStepID})
    MERGE (move)-[:HAS_STEP]->(step)
    RETURN step
    """
  )

  ConnectStepToTechnique(fromStepID: ID!, toTechniqueID: ID!): Step @cypher(
    statement:
    """
    MATCH (step:Step {id: $fromStepID})
    MATCH (tech:Technique {id: $toTechniqueID})
    MERGE (step)-[:USES]->(tech)
    RETURN step
    """
  )

  ConnectAdjacentSteps(prevStepID: ID!, nextStepID: ID!): Step @cypher(
    statement:
    """
    MATCH (prevStep:Step {id: $prevStepID})
    MATCH (nextStep:Step {id: $nextStepID})
    MERGE (prevStep)-[:NEXT_STEP]->(nextStep)
    RETURN nextStep
    """
  )

  InsertStepBetween(prevStepID: ID!, newStepID: ID!, nextStepID: ID!): Step @cypher(
    statement:
    """
    MATCH(prev:Step {id: $prevStepID})-[r:NEXT_STEP]->(next:Step {id: $nextStepID})
    WITH prev, r, next
    DELETE r
    WITH prev, next
    MATCH (new:Step {id: $newStepID})
    MERGE (prev)-[:NEXT_STEP]->(new)-[:NEXT_STEP]->(next)
    RETURN new
    """
  )

  InsertStepNextTo(prevStepID: ID!, nextStepID: ID!): Step @cypher(
    statement:
    """
    MATCH (prev:Step {id: $prevStepID})
    MATCH (next:Step {id: $nextStepID})
    MERGE (prev)-[:NEXT_STEP]->(next)
    RETURN next
    """
  )

  # DeleteStepBetween(prevStepID: ID!, nextStepID: ID!): [Step] @cypher(
  #   statement:
  #   """
  #   MATCH (prev:Step {id: $prevStepID})
  #   MATCH (next:Step {id: $nextStepID})
  #   MERGE (prev)-[:NEXT_STEP]->(next)
  #   RETURN prev, next
  #   """
  # )
}